/* ZCM type definition class file
 * This file was automatically generated by zcm-gen
 * DO NOT MODIFY BY HAND!!!!
 */

package craebot;
 
import java.io.*;
import java.util.*;
import zcm.zcm.*;
 
public final class battery_state_t implements zcm.zcm.ZCMEncodable
{
    public long utime;
    public float voltage;
    public float current;
    public float charge;
    public float capacity;
    public float charge_ratio;
    public short temperature;
    public byte charging_state;
 
    public battery_state_t()
    {
    }
 
    public static final long ZCM_FINGERPRINT;
    public static final long ZCM_FINGERPRINT_BASE = 0x76422464184f6c89L;
 
    public static final byte CHARGE_NONE = (byte) 0;
    public static final byte CHARGE_RECONDITION = (byte) 1;
    public static final byte CHARGE_FULL = (byte) 2;
    public static final byte CHARGE_TRICKLE = (byte) 3;
    public static final byte CHARGE_WAITING = (byte) 4;
    public static final byte CHARGE_FAULT = (byte) 5;

    static {
        ZCM_FINGERPRINT = _hashRecursive(new ArrayList<Class<?>>());
    }
 
    public static long _hashRecursive(ArrayList<Class<?>> classes)
    {
        if (classes.contains(craebot.battery_state_t.class))
            return 0L;
 
        classes.add(craebot.battery_state_t.class);
        long hash = ZCM_FINGERPRINT_BASE
            ;
        classes.remove(classes.size() - 1);
        return (hash<<1) + ((hash>>>63)&1);
    }
 
    public void encode(DataOutput outs) throws IOException
    {
        outs.writeLong(ZCM_FINGERPRINT);
        _encodeRecursive(outs);
    }
 
    public void _encodeRecursive(DataOutput outs) throws IOException
    {
        outs.writeLong(this.utime); 
 
        outs.writeFloat(this.voltage); 
 
        outs.writeFloat(this.current); 
 
        outs.writeFloat(this.charge); 
 
        outs.writeFloat(this.capacity); 
 
        outs.writeFloat(this.charge_ratio); 
 
        outs.writeShort(this.temperature); 
 
        outs.writeByte(this.charging_state); 
 
    }
 
    public battery_state_t(byte[] data) throws IOException
    {
        this(new ZCMDataInputStream(data));
    }
 
    public battery_state_t(DataInput ins) throws IOException
    {
        if (ins.readLong() != ZCM_FINGERPRINT)
            throw new IOException("ZCM Decode error: bad fingerprint");
 
        _decodeRecursive(ins);
    }
 
    public static craebot.battery_state_t _decodeRecursiveFactory(DataInput ins) throws IOException
    {
        craebot.battery_state_t o = new craebot.battery_state_t();
        o._decodeRecursive(ins);
        return o;
    }
 
    public void _decodeRecursive(DataInput ins) throws IOException
    {
        this.utime = ins.readLong();
 
        this.voltage = ins.readFloat();
 
        this.current = ins.readFloat();
 
        this.charge = ins.readFloat();
 
        this.capacity = ins.readFloat();
 
        this.charge_ratio = ins.readFloat();
 
        this.temperature = ins.readShort();
 
        this.charging_state = ins.readByte();
 
    }
 
    public craebot.battery_state_t copy()
    {
        craebot.battery_state_t outobj = new craebot.battery_state_t();
        outobj.utime = this.utime;
 
        outobj.voltage = this.voltage;
 
        outobj.current = this.current;
 
        outobj.charge = this.charge;
 
        outobj.capacity = this.capacity;
 
        outobj.charge_ratio = this.charge_ratio;
 
        outobj.temperature = this.temperature;
 
        outobj.charging_state = this.charging_state;
 
        return outobj;
    }
 
}

